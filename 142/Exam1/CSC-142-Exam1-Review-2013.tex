% Author: David Larsen <dcl9934@cs.rit.edu>
% Author: Doug Krofcheck <dpk3062@rit.edu>
\documentclass[11pt]{article}
\usepackage[margin=0.7in]{geometry}
\usepackage{listings}   %
\usepackage{needspace}  %
\usepackage{color}      %
\usepackage{ifthen}     % 
\usepackage{graphicx}   %
\usepackage{csc}        %
\usepackage{tikz}       %
\usetikzlibrary{shapes} %
\usepackage{tabularx}   % for helping matchtabular (matching questions)
\usepackage{textcomp}	% So our quotes in code don't look like shit
\usepackage{longtable}
\usepackage{multicol}
\setlength{\columnsep}{12em}

\lstset{ %
basicstyle=\footnotesize\ttfamily,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
tabsize=4,		                % sets default tabsize to 4 spaces
language=Java,
upquote=true,
columns=fixed
}

\ifthenelse{\isundefined{\isAnswerKey}}
{
    \newenvironment{answer}{\large\lstset{basicstyle=\large\ttfamily}\color{white} \small{Answer:}}{}
}
{
    \newenvironment{answer}{\large\lstset{basicstyle=\large\ttfamily}\color{red} \small{Answer:}}{}
}

% ----- Start matchtabular definition -----
\newcounter{matchleft}
\newcounter{matchright}
\newenvironment{matchtabular}{%
  \setcounter{matchleft}{0}%
  \setcounter{matchright}{0}%
  \tabularx{\textwidth}{%
    >{\leavevmode\hbox to 1.5em{\stepcounter{matchleft}\arabic{matchleft}.}}X%
    >{\leavevmode\hbox to 1.5em{\stepcounter{matchright}\alph{matchright})}}X% 
    }%
}{\endtabularx}
% ----- End matchtabular definition -----

\title{CSCI-142 Exam 1 Review}
\author{Computer Science Community}
\date{\today}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\begin{document}
\header
\begin{enumerate}


\item Provide a detailed explaination of what the following code does:
\begin{lstlisting}
public boolean checkString(String a, String b) {
	return a == b;
}
\end{lstlisting}
\begin{answer}
Given the two strings $a$ and $b$, checkString() returns true if both string objects have the same memory address.  That means they are both references to the same thing.  The function does not check to see if the two strings have the same string value.  It is possible for two different strings to have the same value (``hellos'') but with different memory addresses.  

Talk about how, by default, Object's equal() checks memory addresses and can be extended by subclasses to check the objects' attributes.  In Java, it is not possible to override how == works.

To check if the contents of the strings are the same, use the {\tt equals} method, defined in the {\tt Object} class and overridden in the {\tt String} class.
For example, {\tt "yes".equals("yes")}.
\end{answer}

\item If an instance variable is declared with {\tt protected} access, who can access it? \\
\begin{answer}
Any class in the same package as the class in which the variable is defined, as well as any subclasses of the latter class.
\end{answer}


\item What is the difference between overriding and overloading methods?  Give a example situation where each should be used. \\
\begin{answer}
\textbf{Overriding:} method with the exact same method declaration as a method in a superclass; overwrites and/or extends the functionality of the super() method.

\textbf{Overloading:} 2 or more methods with the same name and return type that either:
	\begin{enumerate}
	\item have a different number of parameters\\ \textbf{OR}
	\item have parameters of different types
	\end{enumerate}
Override a method when you want to \textit{replace} the implementation of a method in a superclass.  Overload a method (such as a constructor) when you want to have more than one implementation of a method for different circumstances.
\end{answer}


\item Explain the differences between:
\begin{enumerate}
	\item class vs object \\
	\begin{answer}
	A class defines methods and fields---it can be viewed as a template. An object is an instance of a class. Think of classes as molds and objects as individual things created by those molds.
	\end{answer}	
	
	\item constant vs non-constant field (variable).  Declare a constant. \\
	\begin{answer}
	A constant field cannot be changed during run time (it may be set {\em once}).
		\begin{lstlisting}[numbers=none]
public final int NUM_PEOPLE_WHO_LIKE_JAVA = 1;
		\end{lstlisting}
	Note that marking mutable types \texttt{final} only prevents their replacement.
	\end{answer}
	
	\item constant vs non-constant method.  \\
	\begin{answer}
	A constant method can't be overridden by a subclass.
	\end{answer}

	\item class vs instance variable.  Declare variables of both types.\\
	\begin{answer}
	Class (static) variables are scoped to their class not to an object.  All instances of a class access the same static variable.  Each class instance can only reference its own instance (non-static) variable.
		\begin{lstlisting}[numbers=none]
class Types {
	public static int im_a_class_var = 1;
	public int im_an_instance_var = 2;
}
		\end{lstlisting}
	\end{answer}
	
\end{enumerate}



\item Define polymorphism and explain a situation in which you would use it. \\
\begin{answer}
Polymorphism: the ability to create an object of more than one type. References and collections of a super class may hold instances of subclasses. Methods invoked on these objects determine the correct (type specific) behavior at runtime. \\
EX:
		\begin{lstlisting}
ArrayList<Shape> shapes = new ArrayList<Shape>();

// Square with side length of 1
shapes.add(new Square(1.0));

// Circle with radius of 9
shapes.add(new Circle(9.0));

// Triangle with base of 4 and height of 5
shapes.add(new Triangle(4.0, 5.0));

// Outputs the correct area of each shape
for( int i = 0; i < shapes.size(); i++ ){ 
   	double area = shapes.get(i).getArea();
   	System.out.println(area);
}
        \end{lstlisting}
\end{answer}


\item What is the difference between an abstract class and an interface? Why might you want to use an interface over an abstract class? \\
\begin{answer}
Abstract classes allow for default method behavior to be defined, while interfaces allow only method declaration.  Since Java allows a class to extend only a single class but implement many interfaces, interfaces provide some extended capabilities. However, extending an abstract class allows usage of the defined default behaviors. 
\end{answer}


\item What gets printed by the following code?
\begin{lstlisting}
public class Class1 {
	public Class1() {
		System.out.println( "Class1()" );
	}
	public void print1() {
		System.out.println( "Class1.print1()" );
	}
	public void print2() {
		System.out.println("Class1.print2()" );
	}
}

public class Class2 extends Class1 {
	public Class2() {
		System.out.println( "Class2()" );
	}
	public void print1() {
		System.out.println("Class2.print1()");
	}
}
\end{lstlisting}
\textit{(continued...)}
\pagebreak
\begin{lstlisting}[firstnumber=21]
public class Class3 extends Class1{
	private Class2 class2;
	public Class3() {
		System.out.println( "Class3()" );
		class2 = new Class2();
	}
	public void print1() {
		class2.print1();
	}
	public void print2(){
		System.out.println("Class3.print2()");
		super.print2();
	}
}

public class TestClass {
	public static void main( String[] args ) {
		Class1 c1 = new Class2();
		c1.print1();
		c1.print2();

		System.out.println();
		Class1 c2 = new Class3();
		c2.print1();
		c2.print2();
	}
}
\end{lstlisting}
\begin{answer}
\begin{multicols}{2}
\hangindent=4em
    \begin{verbatim}
Class1()
Class2()
Class2.print1()
Class1.print2()
\end{verbatim}
\columnbreak
\begin{verbatim}
Class1()
Class3()
Class1()
Class2()
Class2.print1()
Class3.print2()
Class1.print2()
    \end{verbatim}
\end{multicols}
\end{answer}

\vspace{-24pt}


\item Find at least 3 errors related to inheritance and interfaces in the following code:\label{demolition-derby}
\begin{lstlisting}
public interface Vehicle {
	public int getSpeed();
	public void accelerate(int speed_increase);
	public void brake(int speed_decrease);
}
public class Car implements Vehicle {
	private int speed;
	public Car(int initialSpeed){
		this.speed = initialSpeed;
	}
	public int getSpeed(){
		return speed;
	}
	public int accelerate(int speed_increase) {
		speed += speed_increase;
		return speed;
	}
	public int brake(int speed_decrease) {
		speed -= speed_decrease;
		return speed;
	}
}
\end{lstlisting}

\begin{lstlisting}[firstnumber=23]
public class Toyota extends Car {
	public long getSpeed(){
		return speed;
	}
	public void brake(Integer speed_decrease) {}
	public void factoryRecall(){
		System.out.println("Replace my floor mat!");
	}
}
public class Truck implements Vehicle {
	public void accelerate(int speed_increase) {
		super.accelerate(speed_increase/2);
	}
	public void brake(int speed_decrease) {
		super.brake(speed_decrease/2);
	}
}
public class demolitonDerby {
	public static void main(String[] args) {
		Vechicle	prius, mack, impreza;
		prius = new Toyota();
		mack = new Truck();
		impreza = new Car();
		
		impreza.accelerate(5);
		prius.brake(2);
		prius.factoryRecall();
		prius.accelerate(impreza.getSpeed());
		mack.accelerate(5);
	}
\end{lstlisting}
\begin{answer}
    \begin{tabular}{r l} % TODO Fix some answers here
    Line \# & Error \\\hline
    14  	& Returns int, should return void\\
    17  	& Returns int, should return void\\
    22  	& getSpeed()'s return type ({\tt long}) differs from Car or Vehicle.\\
    23  	& speed is private.\\
    25,46	& Calling brake() on Toyotas will call the superclass's brake()\\
    30  	& Truck implements vehicle, but does not have getSpeed()\\
    32  	& Can't call super(), this has no superclass.\\
    33  	& Can't call super(), this has no superclass.\\
    47  	& {\tt prius} was declared as a {\tt Vehicle}, so we can't call\\
    ~  		& methods that aren't declared in {\tt Vehicle}.\\
    \end{tabular}
\end{answer}


\item Convert the following code to use generics.
\begin{lstlisting}
interface StringCondition
{
	boolean checkString(String s);
}

interface IntegerCondition
{
	boolean checkInteger(Integer i);
}

class StringContainer
{
	ArrayList<String> values;
	
	// Add and other methods are defined correctly here...

	String getFirstWhereHolds(StringCondition condition)
	{
		for (String s : values)
		{
			if (condition.checkString(s))
				return s;
		}
		return null;
	}
}

class IntegerContainer
{
	ArrayList<Integer> values;

	// Add and other methods are defined correctly here...

	Integer getFirstWhereHolds(IntegerCondition condition)
	{
		for (Integer i : values)
		{
			if (condition.checkInteger(i))
				return i;
		}
		return null;
	}
}
\end{lstlisting}

\begin{answer}
\begin{lstlisting}
interface Condition<E>
{
	boolean check(E value);
}

public class Container<E>
{
	ArrayList<E> values;
	E getFirstWhereHolds(Condition<E> condition)
	{
		for (E v : values)
		{
			if (condition.check(v))
				return v;
		}
		return null;
	}
}
\end{lstlisting}
\end{answer}

\end{enumerate}
\end{document}

Note: The following numbers are outdated:

TODO: Eric had a good example during the last review session for the question about polymorphism, which is currently pretty dry. It was about animals trampling people, and maybe we should rework the question to include it.

Topics for this exam:
	- Java basics
		1, 2, 3, 4
	- Classes
	- Inheritance (interfaces & subclasses)
		5?, 6, 7, 8, 9

1) == vs .equals()
2) protected variables
3) overriding vs overloading methods
4) class vs object, constants vs normal, class vs instance, open vs chaining
6) polymorphism
7) abstract class vs interface
8) "What gets printed by the following code?" ... branches of classes
9) Given code of inheritance/interfaces, find errors.
