Consider a simple backtracking algorithm.

\begin{enumerate}
\item What are the four core components of any backtracking \texttt{solve} function?

\begin{answer}
\begin{enumerate}
\item
Checking if the current state is the solution - \texttt{isGoal()}, 
\item
Getting the next possible state - \texttt{getSuccessors()}, 
\item
Checking if the next state is valid - \texttt{isValid()}, 
\item
Calling solve on the new valid state - \texttt{solve()}
\end{enumerate}
\end{answer}

\item Write a generic \texttt{solve()} function for a given configuration, which returns either the solution configuration or \texttt{null} (if no solution exists): \\
(\textit{Hint: make up a function name for each of the parts above, if necessary})
\vspace{.25in}
\begin{lstlisting}[numbers=none]
public Configuration solve(Configuration config) {
\end{lstlisting}
\begin{answer}
\begin{lstlisting}[numbers=none]
	if(config.isGoal()){
		return config;
	}else{
		for(Configuration child : config.getSuccessors()){
			if(child.isValid()){
				Configuration ans = solve(child);
				if(ans != null)
					return ans;
			}
		}
		// implicit backtracking happens here
	}
	return null;
\end{lstlisting}
\end{answer}
\begin{lstlisting}[numbers=none]
}
\end{lstlisting}
\end{enumerate}
